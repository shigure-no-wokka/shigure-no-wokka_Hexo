---
title: 哈希表
date: " 2024-08-31 11:50 "
description: 哈希表总结
cover: https://raw.githubusercontent.com/shigure-no-wokka/pic_bed/main/imgs/family_code.jpg
categories: Code
tags:
  - LeetCode
  - 哈希表
---

## 简述

特殊情况：数组就是哈希表

常用于：**快速判断元素是否出现在集合中**

原理：通过哈希函数，将 Key 映射到数组下标上，之后就可以通过 Key 来直接访问得到 value（可以参考数组中下标访问元素）

## 引申思考

哈希表其实就是数组，那如果需要映射的 Key 数量大于哈希表的大小呢？
- **哈希碰撞**：两个 Key 同时映射到一个**下标位置**上
- 解决办法：
  - **拉链法**
  - **线性探测法**

### 拉链法

将冲突元素都存储在冲突位置延伸出的链表中

关键：哈希表的大小选择要保证**数组空值不能太多防止内存浪费**，有需要保证**链表不要太长，从而影响查找效率**

### 线性探测法

简单粗暴：**保证哈希表的大小一定大于数据大小**
- 如果冲突，就在冲突位置之后的空位置存放

## 常用三种哈希结构

- 数组
- set（集合）
- map（映射）

### C++ 中的`set`

| 集合            | 底层实现 | 有序？ | 可重复？| 可修改？ | 查询        | 增删        |
| --------------- | -------- | -------- | ---------------- | -------- | ----------- | ----------- |
| `std::set`      | 红黑树   | 有序     | 不可             | 不能     | $O(\log n)$ | $O(\log n)$ |
| `std::multiset` | 红黑树   | 有序     | 可以             | 不能     | $O(\log n)$ | $O(\log n)$ |
| `std::unordered_set` | 哈希表 | 无序 | 不可 | 不能 | $O(1)$ | $O(1)$ |

- **红黑树是平衡二叉搜索树，Key 值有序，修改 Key 会导致树的错乱，只能增删**

### C++ 中的`map`

| 映射            | 底层实现 | Key 有序？ | Key 可重复？| Key 可修改？ | 查询        | 增删        |
| --------------- | -------- | -------- | ---------------- | -------- | ----------- | ----------- |
| `std::map`      | 红黑树   | 有序     | 不可             | 不能     | $O(\log n)$ | $O(\log n)$ |
| `std::multimap` | 红黑树   | 有序     | 可以             | 不能     | $O(\log n)$ | $O(\log n)$ |
| `std::unordered_map` | 哈希表 | 无序 | 不可 | 不能 | $O(1)$ | $O(1)$ |

- `map`要求 Key 不可重复，Key 的存储通过红黑树实现


## 做题时使用到的

```cpp
unordered_set<int> ret;
// vector to initialize set
unordered_set<int> nums(vec.begin(), vec.end());

// Find target
ret.find(target) != ret.end();

// Insert
ret.insert(target);

// Cast to vector
vector<int>(ret.begin(), ret.end());
```



# 参考链接
- [C++ STL 学习笔记 : 2. unordered map 容器\_unordered\_map 访问第一个元素-CSDN 博客](https://blog.csdn.net/Cy_coding/article/details/105804617)



---
title: 0011.盛最多水的容器
date: " 2024-08-31 12:15 "
description: 
cover: https://raw.githubusercontent.com/shigure-no-wokka/pic_bed/main/imgs/family_code.jpg
categories: Code
tags:
  - LeetCode
  - 双指针
---

题目链接：[11 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)


<!--more-->

---

# 题解

### 双指针法

利用双指针从容器首尾两端向中间遍历，分别记为 `i` 和 `j`，每次移动后的容积为：`S(i, j)`

计算公式为：

$$
S(i, j) = (j - i) \cdot \min(h[i], h[j])
$$

接下来分析两个指针的更新条件：

初始条件下，`i` 和 `j` 位于容器两端，此时 `j-i` 为最大，当双指针开始向内遍历时

- `j-i`: 逐渐变小，导致 `S(i,j)` 变小
- `min(h[i],h[j])`: 可能变大可能变小

综上，`j-i` 固定变小，想要使得 `S(i,j)` 变大，一定只会发生在 `min(h[i],h[j])` 变大的情况下，即**取决于每次双指针的短板是否能比上一次的短板更长**

因此，需要对比 `h[i]` 和 `h[j]` 大小，并移动短板指针

**疑问：如果 `h[i]` 和 `h[j]` 相等呢？**

此时假设移动了其中的一个指针 `i`，分类讨论：
- `h[i+1]>h[i]`：短板仍为 `h[j]` 不变，宽度变小 `j-i-1`，此时 `S(i+1, j)` 一定变小
- `h[i+1]<=h[i]`：宽度必定变小，高度可能变小，面积是必定变小的

移动指针 `j` 也是同理

只有两个指针**都移动到**了比当前短板更高的位置时，才可能使得容积比此时更大，即：
- 要想让此情况下，更新指针后容积变大，**只移动一个指针必然不可能使得容积变得更大**
- **只有在两个指针都移动之后，才有可能容积变大**
- **不需要考虑两个指针移动的先后顺序**，尽管会跳过很多种组合可能性，但这些可能性正如分析的那样，是不可能出现比当前情况更大的容积的

下面是代码实现：

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int slow = 0;
        int fast = height.size()-1;
        int area = 0;

        while(slow != fast)
            area = (height[fast]<height[slow])?
                max(area, (fast - slow) * height[fast--]):
                max(area, (fast - slow) * height[slow++]);
        return area;
    }
};
```

复杂度分析：
- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



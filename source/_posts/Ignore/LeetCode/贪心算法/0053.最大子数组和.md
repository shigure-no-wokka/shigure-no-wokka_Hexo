---
title: 0053.最大子数组和
date: " 2024-08-31 12:16 "
description: 
cover: https://raw.githubusercontent.com/shigure-no-wokka/pic_bed/main/imgs/family_code.jpg
categories: Code
tags:
  - LeetCode
  - 贪心算法
---

题目链接：[53 最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/)

<!--more-->

---

# 题解

## 方法一：贪心算法

### 题解

首先总结一下能使得数组变大的情况

- 只有加上正数才能变大，负数只会让和变小
- 对于只有负数的特殊情况，则需要找到其中最大的一个负数

那么利用贪心算法，要想使得全局子数组和最大，则需要使得局部即每次求和时尽可能大

即，局部计算时，如果求和为负数，则要重新从下一个位置开始计算，此时要重置求和`if(sum < 0) sum = 0`

综上，

```cpp
int maxSubArray(vector<int>& nums)
{
    int sum = 0;
    int ret = INT_MIN;
    for(int i = 0;i<nums.size();++i)
    {
        sum += nums[i];         // 记录每次求和结果
        ret = max(ret, sum);    // 记录最大值
        if(sum<0) sum = 0;      // 当前求和为负数则需要重新计算
    }
    return ret;
}
```

复杂度分析：
- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$

### 误区分析

- 遇到负数重新选择起始位置，还是连续和为负数选择起始位置

要明确最终要得到的是连续和最大的子数组，也就是目标是连续和最大

那么，就算当前是负数，但只要求和结果仍然为正数，则其对于后续计算都是起到递增的作用


## 方法二：动态规划

- [参考这个](../动态规划/053.最大子序列和.md)


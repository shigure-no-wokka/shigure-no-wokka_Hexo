---
title: KMP算法
date: " 2024-08-31 12:22 "
description: 
cover: https://raw.githubusercontent.com/shigure-no-wokka/pic_bed/main/imgs/family_code.jpg
categories: Code
tags:
  - LeetCode
  - KMP算法
---

题目链接：

KMP 算法要解决的问题：给出一个文本串：`aabaabaaf`，和一个模式串：`aabaaf`，要求判断文本串中是否出现过给定的模式串

暴力解法：嵌套循环，复杂度为 $O(m * n)$，m n 分别为文本串和模式串的长度

<!--more-->

---

## 前缀表

KMP 算法需要借助前缀表实现

核心思想：在不匹配位置之前，是否已经出现过和模式串开头一段长度相同的字符串，例如上述问题中不匹配位置`f`之前出现过`aa`，而模式串开头正好有一串`aa`，这意味着
- **我们不需要再重新对模式串的前缀`aa`进行匹配判断，而是直接从`aa`之后的`b`字符开始匹配判断即可**

## 前缀与后缀

前缀：**包含首字母，不包含尾字母**的所有子串（如`aa`、`aabaa`等，`aabaaf`则不是，因为不能包含尾字母）
后缀：**包含尾字母，不包含首字母**的所有子串（如`aaf`、`baaf`等，`aabaaf`则不是，因为不能包含首字母）

## 最长相等前后缀

从而 KMP 算法的核心就可以写为：找到模式串所有子串的**最长相等前后缀**

| substring | longest equal suffix |
|-----------|----------------------|
| a         | 0                    |
| aa        | 1                    |
| aab       | 0                    |
| aaba      | 1                    |
| aabaa     | 2                    |
| aabaaf    | 0                    |

从而可以写出前缀表

| a | a | b | a | a | f |
|---|---|---|---|---|---|
| 0 | 1 | 0 | 1 | 2 | 0 |

用法：根据不匹配位置，找到该位置之前子串的**最长相等前后缀长度**，即，`f`不匹配后，找`aabaa`的**最长相等前后缀长度**，查表可知为 2，则下一次匹配需要在下标为 2 的位置，即`b`处重新匹配

## Next 数组含义

当位置 i 处的字符不匹配时，要跳回到 Next[i] 位置重新匹配


## 代码实现

使用 next 进行模式串匹配好理解，问题在于理解计算 next 数组的方法和代码实现

### 方式一

> next 表示当前子串的最长相等前后缀长度

初始化：
- 模式串的子串末尾（也是子串的后缀尾）：`int i;`
- 子串的前缀尾：`int j;`，**也代表着最长相等前后缀的长度**
- next 数组的第一个位置固定为：`next[0] = 0`

情况一：`s[i]!=s[j]`
- 由于前后缀的末尾字符不匹配，需要将前缀回退 `j = next[j-1];`
- **为何这么回退？**：这里的 next 数组表示的是当位置 k 不匹配时，要找到前一个位置即 k-1 的 next，这个才是需要回退并重新开始匹配的位置（**循环不变量**，在这里即为：不匹配则回退到前一个位置的 next）
- **什么时候停止回退？**：`s[i]==s[j]`时，需要注意，回退时会进行 `next[j-1]` 的操作，所以 j 最小会取到 0，故这里还需要加上 `j>0` 的条件，当 `j == 0` 时就不再回退了

情况二：`s[j]==s[i]`
- j 同样代表着最长相等前后缀的长度，由于当前的前后缀的末尾相等，说明这个最长相等前后缀的长度发生了 +1，即：`++j;`

最后记录**最长相等前后缀的长度**，即：`next[i] = j;`

代码如下：

```cpp
void GetNext(std::string &s, int (&next)[]) {
    // 初始化
    int i = 1, j = 0;
    next[0] = 0;
    // 开始遍历
    for(i=1;i<s.size();++i) {
        // 前后缀尾不相等时回退
        while(j>0 && s[i]!=s[j]) {
            j = next[j-1];
        }
        // 前后缀尾相等时，最长相等前后缀长度 +1
        if(s[i]==s[j]) {
            j++;
        }
        // 更新 next 中的记录
        // 注意：这里的 next 表示的就是最长相等前后缀长度
        next[i] = j;
    }
}
```

**关键：next 存储的为模式串各个子串最长相等前后缀长度**

- `i` 表示后缀尾，也表示当前要找的子串末尾
- `j` 表示前缀尾，又表示最长相等前后缀长度

所以，子串末尾在位置 `i` 时，子串的最长相等前后缀长度应该为 `next[i] = j;`


### 方式二：

> next 表示
>
> 当主串和模式串某一位置 i 的字符不匹配时，模式串的回退位置 next[i]

这里的回退位置直接从对应不匹配下标的 next 获取

所以有：`next[j] = 前 j-1 字符组成的子串的最长相等前后缀长度 + 1`

代码实现：

```cpp
void GetNext(std::string &s, int (&next)[]) {
    // 初始化
    int i = 1, j = 0;
    next[0] = 0;
    // 遍历
    while(i<s.size()) {
        if(j==0 || s[i] == s[j]) {
            next[++i] = ++j;
        }
        else {
            j = next[j];
        }
    }
}
```


## 两种实现方法的分析

- 方法一中 next 表示的是长度 `nextLen`
- 方法二中 next 表示**回退到的位置 `nextPos`**

二者满足`nextPos[j] = nextLen[j-1] + 1;`

对于第一个字符，模式串下标为 0 的位置，仍然取 0，即`next[0] = 0;`

以模式串：`"abaabcac"` 为例：
- 方法一的 next：0 0 1 1 2 0 1 0
- 方法二的 next：0 1 1 2 2 3 1 2

当位置 i 不匹配时
- 方法一要回退到 `next[i-1]`
- 方法二要回退到 `next[i]`


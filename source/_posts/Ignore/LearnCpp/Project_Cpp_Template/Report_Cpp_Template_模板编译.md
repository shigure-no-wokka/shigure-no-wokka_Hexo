---
title: Cpp 模板：模板编译
date: 2024-04-26 20:12:30
description: C++ 模板学习
cover: https://raw.githubusercontent.com/shigure-no-wokka/pic_bed/main/imgs/family_code.jpg
categories: Code
tags:
  - 模板
  - Cpp
---

# 编译器遇到模板定义不生成代码，只有使用到模板的时候实例化对应版本

一般来说，编译器遇到模板的定义时不会生成代码。

```cpp
template<typename T>
T Test(const T&) { return T(); }
```

只有在使用模板的时候，编译器才会用模板实例化一个对应的版本。

```cpp
Test<int>(1); // 生成一个 int 的版本
Test<char>('c'); // 生成一个 char 的版本
```

# 模板类中的模板成员函数的定义位置

一般对于函数，编译器只需要知道函数的声明。对于类，编译器需要知道类的定义，但成员函数的定义不必出现

因此类的定义和函数声明在头文件，而函数和成员函数的定义在源文件中。

但对于模板，编译器需要在编译期间生成对应版本的实例，需要知道模板的定义（函数模板或类模板成员函数）

因此，**模板的头文件一般会同时包括声明和定义**


# 模板内代码的编译错误报错时机

1. 编译模板本身：只会检查语法错误
2. 编译器遇到模板使用：对于函数模板调用，检查实参数量、参数类型匹配。对于类模板，检查模板实参
3. 模板实例化：**这里才能发现类型相关错误**

例如：
```cpp
class A;
A a1, a2;
cout << compare(a1, a2) << endl;
```

A 没有重载运算符`<`，这串代码会报错，但这个报错只会在编译器在这里实例化模板时才能发现

# C++ 程序员更喜欢使用`!=`而不是`<`

原因是，大多是类之定义了`!=`，使用`!=`可以降低对要处理的类型的要求。


